import UIKit

/*
 1. class
 클래스와 구조체는 모두 열거형과 같은 커스텀 타입이다.
 타입을 정의해 두면 나중에 변수 등으로 사용할 수 있다.
 */

class Dog { // class 키워드 뒤에 타입으로 사용하고 싶은 이름을 정한다. 타입이므로 대문자로 시작해야 한다.
    var name = "강아지" // class안에 변수를 선언할 수 있다.
    var weight = 0.0
}

var leo: Dog = Dog() // 위에 정의한 Dog타입이다. ()은 초기화의 의미인데 다음 파일에서 자세하게 배우자.
leo.name // 이렇게 정의된 변수를 사용하는 것도 가능하다.
leo.weight
leo.name = "Leo" // 당연히 변경도 가능하다.
leo.name

var choco = Dog() // 하나의 클래스에 대해 여러 강아지들을 만들 수 있고 클래스로 인해 만들어진 것을 인스턴스 또는 객체라고 부른다.
choco.name = "Choco"
choco.name

class Dog2 {
    var name = "강아지"
    var weight = 0.0
    
    func sit() { // class안에 함수도 사용이 가능하다. 참고로 클래스 안의 변수는 속성 또는 프로퍼티(property), 함수는 메서드(method)라고 부른다. 이건 꼭 기억해두자
        print("앉았습니다.")
    }
}

var leo2 = Dog2()
leo2.sit() // 이런 식으로 사용할 수 있다.
var leo3 = Dog2()
leo3.sit() // 하지만 이렇게 여러 객체가 같은 함수를 쓰면 어떤 객체에서 쓴 함수인지 헷갈릴 수 있다.

class Dog3 {
    var name = "강아지"
    var weight = 0.0
    
    func sit() {
        print("\(name)가 앉았습니다.") // 그래서 이렇게 클래스 내부의 변수를 사용할 수 있다.
    }
}

var leo4 = Dog3()
leo4.sit()
leo4.name = "Leo"
leo4.sit()




/*
 2. struct
 구조체는 클래스와 겉보기엔 다른게 없다.
 */

struct Bird { //class에서 struct라는 키워드로 바꼈을 뿐 다른게 보이지 않는다.
    var name = "새"
    var weight = 0.0
    
    func fly() { // 클래스는 물론 구조체도 함수에 파라미터를 사용하는 것이 가능하다.
        print("\(name)가 날아갑니다.")
    }
}

var bird = Bird() // 사용할때도 클래스와 똑같은 방법으로 사용한다.
bird.fly()
bird.name = "참새"
bird.fly()




/*
 3. 클래스와 구조체의 차이
 클래스와 구조체 모두 지금까지 보기엔 완전히 같은 방법인것처럼 보인다.
 하지만 차이를 잘 이해하고 필요한 경우에 사용해야한다.
 우선 클래스와 구조체 모두 타입 자체는 메모리의 데이터 영역에 올라간다.(나중에 더 자세하게 배울 예정)
 클래스는 참조타입이라고 하는데, 데이터 영역에 있는 자신의 클래스 주소, ARC, 클래스의 속성들을 힙에 저장한다. (참고로 힙 영역은 비어있는 곳을 찾아 알아서 배정한다. 전에 함수에서 배웠든 스택 영역은 순서대로 쌓이고 나중에 쌓인것 먼저 없어지는 형태와 다르다. 또한 ARC등 처음 보는 단어는 우선 무시하고 진행하자)
 예를 들어, var leo = Dog()으로 했을 때 "강아지", 0.0과같은 속성들은 힙 영역에 저장되는 것이다. 그리고 여기서 leo라는 변수는 스택영역에 올라가게 되는데 main에서 진행되고 있다고 가정하면 main함수 안에 leo가 선언되고 leo가 갖는 값은 힙에 있는 leo의 객체의 주소값이다.
 구조체는 값타입이라고 하는데, 스택영역에 값 자체가 복사되어 진다. main함수에서 실행할 때 구조체가 선언이 된다면 main함수 안 구조체의 공간에 "새", 0.0과 같은 값이 들어가게 되는 것이다.
 */




/*
 4. 클래스와 구조체의 메모리 / 복사
 3번에서 말한것처럼 저장되는 것 자체가 달라 코드에서도 보이는 것이 있는데 우선 메모리에서 보자면 클래스는 변수가 갖는 값이 힙 영역에 있는 주소라고 했다. 그렇기 때문에 변수를 복사한다면 주소를 갖게 될 것이고 같은 객체를 공유하게 된다.
 구조체는 값 자체를 갖고 있기 때문에 복사하게 되면 저로 다른 독립적인 객체를 갖고 있는 것이 된다. 아래 예시로 확인해보자.
 */

var bori = Dog()
var yangang = bori // 양갱이란 변수에 보리를 할당했는데 여기서 보리가 갖고 있는 값은 Dog의 name, weight같은 변수들이 아닌 주소값 자체를 갖고 있다. 그래서 양갱에는 지금 주소값이 할당되어 있고 보리와 양갱 모두 같은 주소를 가르키고 있는 것이다.

bori.name = "Bori"
bori.name // 당연히 name에 Bori를 넣었으니 Bori가 출력된다.
yangang.name // 보리와 같은 주소를 가르키기 때문에 따로 변경을 하지 않았음에도 Bori가 출력된다.

var bird2 = Bird()
var bird3 = bird2 // 3에는 2의 값 자체가 복사된 것이라 현재까진 서로 같은 값을 갖고 있다. 하지만 서로 독립적인 객체이기 때문에 하나를 변경하더라도 다른 하나는 변하지 않는다.

bird2.name = "비둘기"
bird2.name
bird3.name




/*
 5. let 선언
 클래스와 구조체에는 let선언에도 차이점이 존재한다. let으로 선언된다는 것은 현재 담겨져 있는 변수를 바꿀 수 없다는 것인데
 클래스는 주소값을 갖고 있기 때문에 클래스 내부 속성들은 변경할 수 있다.
 그러나, 구조체는 값 자체를 갖고 있기 때문에 let으로 선언하게 되면 구조체 내부 속성들을 변경할 수 없다.
 */

let dog10 = Dog()
dog10.name = "10번째 강아지"
dog10.weight = 10.0

let bird10 = Bird()
//bird10.name = "10번째 새" // 여기만 불가능하다.
//bird10.weight = 2.0
