import UIKit

/*
 1. Dictionary
 딕셔너리는 키와 값의 쌍으로 이뤄진 바구니다.
 키로 값을 찾으며 이 때문에 순서가 없다는 특징이 있다.
 키가 핵심으로 키 값은 중복될 수 없다.
 hash형태로 키 값을 구분한다.
 */

var a: [Int: String] = [0: "Triple", 1: "Swift", 2: "iOS"] // 이 딕셔너리 기준으로 Int가 키, String이 값이 된다.
var b = [0: "Triple", 2: "iOS", 1: "Swift"]

a == b // 배열과 다르게 딕셔너리는 순서가 없기 때문에 순서가 다르더라도 키와 값만 같으면 같은 딕셔너리로 본다.




/*
 2. Hashable
 hash함수는 특정 값을 고정된 길이의 숫자나 문자열로 변환하는 특징이 있는데
 예를 들어 0 -> 12345, 1 -> 12366, 2 -> 12377 등으로 변환한다.(실제로 저 값으로 해시되진 않음 이해를 위해 간단히 표현함)
 딕셔너리는 이 키의 해시값을 보고 빠르게 검색할 수 있다.
 또한, 해시로 키를 특정한 값으로 변환하고 쭉 사용하기 때문에 키 값이 중복될 수 없는 것이다.
 */




/*
 3. 딕셔너리의 접근
 딕셔너리도 배열과 마찬가지로 서브스크립트 문법으로 접근하게 된다.
 []안에 키를 넣으면 값이 나오게 되며 딕셔너리는 키로 값을 찾는게 기본이기 때문에 값만 따로 불러낼 수 없다.
 */

var vote = [1: 10, 2: 9, 3: 5]
vote[1]
vote[2]
vote[3] // 각 키에 대응하는 값을 가져오게 된다.

vote.keys
vote.values // 키와 값이 어떤 데이터로 이뤄져있는지 볼 수 있다.

vote.count
vote.isEmpty // 배열과 같이 몇개의 데이터 쌍이 있는지, 비어있는지 알 수 있다.




/*
 4. 딕셔너리 다루기
 배열과 다른 점은 배열에서의 삽입, 변경, 추가는 딕셔너리에서 모두 업데이트로 통일한다.
 순서가 없다는 것에 차이점이 있는데 배열과 딕셔너리의 차이를 잘 생각해보면 당연하게 느껴진다.
 배열과 마찬가지로 이런것이 있다 정도만 알아두면 좋다. 지금 다 외우기엔 분명 많은 함수가 있기에 조금 무리일 수 있다.
 */

vote.updateValue(50, forKey: 4) // 4라는 키 값은 원래 없었다. 추가가 되는 것(원래 아무것도 없었다면 nil을 반환함)
vote.updateValue(40, forKey: 4) // 4라는 키 값을 바로 위에서 추가해줬다. 값만 40으로 변경됨(원래 4라는 키에 대응하는 값인 50이 반환된다. 언젠간 필요로 할 수도 있는 반환이기 때문에 애플에서 만들어둔 듯 하다.)
vote.updateValue(11, forKey: 1) // 1이라는 키 값은 원래 있었다. 값만 11로 변경된다.(원래 있던 10이라는 값을 반환해준다.)
print(vote)

vote.removeValue(forKey: 2) // 특정 키 값만 지우는 방법
print(vote)
vote.removeAll() // 딕셔너리 전체를 지우는 방법
print(vote)
vote = [:] // 이것 또한 딕셔너리 전체를 지우는 방법이다.
