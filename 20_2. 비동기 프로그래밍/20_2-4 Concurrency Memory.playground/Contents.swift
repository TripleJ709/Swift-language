import UIKit

/*
 1. 동시성 프로그래밍의 메모리 구조
 만약 여러 스레드에서 일을 한다면 메모리 구조는 어떻게 될지 알아보자.
 전에 언급한적 있지만 코드, 데이터, 힙영역과 스택영역을 나눠 생각해야한다.
 코드, 데이터, 힙 영역은 공유하는 영역이다. 순차적이지도 않고 주소를 이용해 참조하며 값을 찾는다.
 하지만 스택 영역은 함수부터 시작해 계속 설명했듯 순차적으로 쌓인다. 이럴때 여러 스레드에서 접근을 한다면 하나의 스택 영역은 제대로 동작할 수 없을 것이다.
 그래서 동시성 프로그래밍에서 메모리 구조는 스레드의 갯수만큼 스택 영역이 늘어난다고 보면 된다.
 스레드를 현재 3개 사용하고 있다고 가정하면
 1번 스택영역, 2번 스택영역, 3번 스택영역이 생겨 각각에서 스택 영역의 처리를 하게 된다.
 */




/*
 2. 동시성 프로그래밍의 문제점(Thread-safe)
 자세히 알고 싶다면 운영체제를 따로 공부하면 더 자세하게 알 수 있을 것이다.
 만약 아래와 같은 상황이 있다고 보자.
 */

class A {
    var name = "Leo"
}

var a = A()

//DispatchQueue.global().async {    // 현재 이 코드들은 동시에 실행이 될 것이다. 그런데 만약 a.name이라는 곳에 동시에 값을 읽기도 하면서 쓰기까지 한다면 OS는 어떻게 해야할지 모르게 될 수도 있다.
//    a.name                        // 물론 지금 주석을 풀어보면 에러가 나게 되는데 이는 Swift에서 미리 스레드를 안전하게 사용하고 있기 때문이다.
//}                                 // 이런 상태를 최대한 지양해야 하며 앞서 간간히 나왔던 @MainActor가 이것과 관련된 문법이였다.
//                                  // OS는 이런 문제를 지양하기 위해 어떤 메모리에 접근하게 되면 그 메모리에 대한 작업이 끝날 때까지 외부에서 더이상 접근할 수 없도록 잡근다.(Lock을 건다.)
//DispatchQueue.global().async {
//    a.name = "triple"
//}

// 또는 a1, a2라는 객체가 있다고 가정을 해보자.
// 스레드 또한 현재 2개가 동시에 사용되고 있다고 가정해보자.
// 스레드1에서 a1에 대해 접근한 뒤 3초 뒤에 a2에 접근하려한다.
// 스레드2에서도 a2에 접근한 뒤 3초 뒤에 a1에 접근하려 한다.
// 그럼 여기서 a1과 a2모두 각각 스레드에서 접근했으므로 Lock이 걸려있다.
// 하지만 3초 뒤에 스레드들이 다른 객체에 접근하려 하는데 Lock이 걸려있어 접근하지 못하고 작업을 끝내지 못하는 상황이 나온다.
// 이런 상태를 교착상태라고 하는데 당연히 OS에서 처리하는 다양한 방법들이 있다.(궁금하면 따로 배워보는 것을 추천)

// 위 설명에 대한 예시이다.
var array = [String]()

let serialQueue = DispatchQueue(label: "serial")


for i in 1...20 {
    DispatchQueue.global().async {
        print("\(i)")
        //array.append("\(i)")      // 이 방법을 사용하게 되면 20번을 읽고 쓰고 하다가 중간에 한번씩 충돌이 날 수가 있다.(위 예시처럼) 이렇게 실행하면 모든 값이 array에 들어가지 않을 수 있다. 물론 지금 Swift에서는 안전하지 않은 코드로 분류해 실행이 되지 않는다.
        
        serialQueue.async {
            DispatchQueue.main.async {
                array.append("\(i)")        // 그래서 이런 방법을 사용한다. 직렬큐를 만들고 모든 값이 순차적으로 실행이 될 수 있도록 한다. 이러면 교착상태가 발생하지 않는다.
            }
        }
    }
}

DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
    print(array)
}
