import UIKit

/*
 1. 힙 영역을 관리해야하는 이유
 몇번 언급했듯이 메모리 구조는 코드, 데이터, 힙, 스택 영역으로 나눠져있다.(물리적으로 나눠진 것은 아니라고 언급도 했었다.)
 코드 영역에는 개발자가 구현한 모든 코드가 올라가게 되고
 데이터 영역에는 전역변수, 타입변수와 같은 것들이 올라가 앱이 꺼지기 전까지 존재하게 된다.
 스택 영역에는 함수들이 실행될 때마다 하나씩 쌓이며 함수가 종료되면 자동으로 없어진다. 스택 영역에서는 이 자동으로 없어지는 것이 중요한데, 자동으로 없어지기 때문에 개발자가 따로 신경을 쓸 필요가 없는 것이다.
 반면에 힙 영역은 인스턴스나 클로저들이 존재하게 되는데 여기서는 개발자가 직접 없애지 않으면 계속 존재하게 된다.
 불필요한 객체들이 계속 존재하면서 힙 영역의 사용 범위를 줄일 경우 심하면 앱이 꺼지기도 할 수 있다.
 어느정도 간단한 코드들은 딱히 신경을 쓰지 않더라도 자동으로 사라지지만 서로를 가르키는 등(이번 챕터에서 배울 내용들임) 개발자가 분명 신경써야 하는 상황들도 여럿 존재한다.
 */




/*
 2. RC, ARC
 Swift에서는 ARC라는 메모리 관리 방법을 선택했다. 힙에 있는 객체나 클로저들이 자신을 가르키고 있는 상대가 얼마나 있는지를 알고 있다가 자신을 가르키는 상대가 0이 되었을 때 자동으로 힙에서 없어지게 된다.
 그래서 개발자는 딱 이 가르키고 있는 상태만 신경써주면 된다.
 RC는 Reference Counting의 약자로 참조 갯수를 생각하면 된다. ARC는 automatic이 붙어 자동으로 해준다고 생각할 수 있다.
 여기서 자동이란 메모리 관리를 자동으로 해주는 것이 아닌 RC를 직접 컨트롤 하지 않는다는 것을 의미한다.
 */

class A {
    var x = 10
}

var a: A? = A()     // 여기 생성자를 사용해 객체를 만들때 자동으로 a인스턴스에 RC가 1이 올라간다.
a = nil             // 이렇게 nil을 할당하는 순간 RC가 1줄어들어 0이 된다.
                    //     -----------      //a인스턴스는 힙영역 내부에서 이렇게 존재한다고 볼 수 있다.
                    //     | A의 주소  |      //여기서 RC의 값을 갖고 있고 0이 되는 순간 힙 영역에서 자동으로 사라진다.
                    //     | RC      |      // RC의 값을 올리고 내리고는 Swift에서 자동으로 해주지만 0이 되는(또는 0이 되지 않도록 하는) 관리는 개발자가 직접 해야한다.
                    //     | var x값  |
                    //     -----------

/*
 3. 강한 참조 사이클과 메모리 누수
 예시를 보고 이해해보자. 여기 예시에서는 메모리에서 해제되지 않아 메모리 누수를 만든다.
 */

class Dog {
    var name: String
    var owner: Person?
    
    init(name: String) {
        self.name = name
    }
    
    deinit {
        print("\(self.name)이 메모리에서 해제됨.")
    }
}

class Person {
    var pet: Dog?
    
    deinit {
        print("사람 객체가 메모리에서 해제됨")
    }
}

var leo: Dog? = Dog(name: "Leo")    // 여기선 현재 leo라는 변수가 힙영역의 인스턴스를 가르키고 있다. 그래서 RC가 1이 되었다.
var person: Person? = Person()      // 여기선 person이라는 변수가 Person타입의 인스턴스를 가르키고 있다. 힙 영역의 인스턴스는 RC가 1이 된다.

leo?.owner = person
person?.pet = leo       // 각각 서로를 가르키도록 했다. 결국 두 인스턴스는 각각을 가르키며 RC가 둘 다 2가 되었다.

leo = nil           // 두 인스턴스를 모두 nil을 주었기 때문에 변수에서 더이상 인스턴스를 가르키지 않는다 RC가 1이 되었다.
person = nil        // 하지만 RC가 0이 되어야 메모리에서 없어지게 되는데 서로를 가르키고 있어 메모리에서 사라지지 않는다.
                    // 여기서 문제가 생기는데 변수에서 접근이 불가능하기 때문에 더이상 메모리를 먹고 있는 저 두 인스턴스를 없앨 방법이 없다.



/*
 4. 약한 참조(weak)와 비소유 참조(unknown)
 두 키워드는 모두 RC를 올리지 않는다는 특징이 있다.
 차이점으로는 weak로 선언된 변수는 해당 변수가 가르킬때 nil이라면 nil을 반환하게 된다.
 하지만 unknown으로 선언된 변수는 해당 변수가 nil이라면 값을 반환하지 않기 때문에 에러가 나게 된다.
 사람이 느낄 수 없을 정도의 차이겠지만 unknown이 더 빠르다고 한다.
 하지만 에러가 날 경우가 있어 에러가 나지 않도록 코드를 추가해야 하기 때문에 적응이 되기 전까지 weak를 쓰는 것이 편하다.
 적은 프로젝트 경험이지만 어떤 앱을 만들때 아직까지 unknown키워드를 사용해본적이 없다. 물론 unknown키워드를 몰라도 된다는 것은 아니다.
 */

class Dog1 {
    var name: String
    weak var owner: Person1?
    
    init(name: String) {
        self.name = name
    }
    
    deinit {
        print("\(self.name)이 메모리에서 해제됨.")
    }
}

class Person1 {
    weak var pet: Dog1?
    
    deinit {
        print("사람 객체가 메모리에서 해제됨")
    }
}

var leo1: Dog1? = Dog1(name: "Leo")
var person1: Person1? = Person1()

leo1?.owner = person1
person1?.pet = leo1

leo1 = nil
person1 = nil       // 위와 똑같은 예제인데 owner, pet변수 앞에 weak를 썻다. RC를 1 올리지 않는다는 의미인데 이러면 왜 두 인스턴스 모두 메모리에서 해제되는지 생각해보자.


var leo2: Dog1? = Dog1(name: "Leo")
var person2: Person1? = Person1()

leo2?.owner = person1
person2?.pet = leo1

leo2 = nil
person2?.pet        // 여기에 접근하면 leo2가 해제되었기 때문에 pet을 읽을 때 nil이 나온다.(앱이 꺼지지 않는 안전함)
                    // unknown으로 바꿔보고 어떤 차이가 있는지 찾아보자.


